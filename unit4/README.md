## 第4章 操作系统的内存管理
### Part 1 ：深入理解虚拟内存
#### 引言（what）
在计算机系统中，内存都是一种紧缺但又宝贵的资源，应用程序必须在载入内存后才能执行。以前在内存空间不够大的时候，操作系统只能同时运行有限个应用程序，甚至当某个应用程序在某个运行时所需的内存超过物理内存时，该应用程序就会无法运行。解决这个问题的方法就是引入今天的主题——虚拟内存。

#### 为什么要有虚拟内存？（why）
虚拟内存就是要让一个程序的代码和数据在没有全部载入内存的时候即可运行。

#### 如何做到没有全部载入内存就可以运行的呢？（how）
虚拟内存管理器动态地将部分代码或数据从硬盘载入到内存中，而且在通常情况下，虚拟内存管理器也会相应的将内存中的某些代码或者数据置换到硬盘中，为即将载入的代码或者数据腾出空间。
一言以蔽之：虚拟内存通过某种机制或是算法之类的实现硬盘空间代替内存暂时存储的功能。

#### 需要考虑的问题：
* 置换算法：当内存不够的时候，如何选择内存中的某一个部分将其置换到硬盘中。
* 维持比例：各个进程在逻辑上相互独立，在内存空间也是『独享』一块内存空间，但是实际上他们『共享』了一块物理内存空间，只是合理的分配其比例大小和未知使得其逻辑上独立，但不同进程的要求和功能不同，其所需的内存也需要动态的调整，如何分配比例。

一家之言：从个人的理解角度，如果内存充足也不需要虚拟内存技术，虚拟内存只是**缓解**内存不足的情况，到最后还是要涉及到硬盘到内存之间的置换IO操作，很大一部分努力是在减少磁盘IO次数，以提高程序的运行性能。

#### Window内存管理
重要的话和概念整理：
##### 使用虚拟内存
1）Win32虚拟内存管理器`为每个Win32进程提供了进程私有且基于页的4GB（32位）大小的线性虚拟地址空间`。

分析：
* 进程私有：每个进程智能访问属于自己的地址空间，不用担心自己的地址空间会被其他进程看到，（父子进程例外，比如调试器利用父子进程关系来访问被调试进程地址空间），需要注意这里强调了进程运行时的dll并没有属于自己的虚拟地址空间，而是在其所属的进程的虚拟地址空间上申请开辟的。
* 基于页：虚拟地址空间被划分尾多个页单元，页的大小由底层处理器决定，x86中的页的大小为4KB。页是Win32虚拟内存管理器处理的最小单元，相应的物理内存页被划分为多个页，虚拟内存地址空间的申请和释放，以及内存和磁盘的数据传输或置换都是以页为最小单位进行的。
* 4GB：进程中的地址取值范围可以从0x00000000 到 0xFFFFFFFF，Win32将低区的2GB留给进程使用，高区的2GB留给系统使用。

2）Win32中赋值实现虚拟内存的硬盘文件称为『调页文件』，可以有16个，调页文件用来存放被虚拟内存管理器置换出内存的数据。
* 调页文件：这一章会反复出现调页文件这个专业名词，从概念上来讲，它其实是物理内存的备份文件，备份在了硬盘上。

3）当进程执行某段代码或者访问某些数据，而这些代码或者数据还没有在内存时，这样的情形称为『缺页错误』。
* 缺页错误：缺页错误也是这一章的重点，就是指在物理内存中找不到。最常见的一种情形是：代码和数据被虚拟内存管理器置换出了内存，这时虚拟内存管理器将这段代码执行后者这些数据被访问前将它们调入内存，这个操作对于开发人员来说是透明的。但是缺页错误涉及到磁盘IO，大量的缺页错误会大大降低程序的总体性能，因此需要提高程序的性能，需要了解缺页错误的主要原因，以及规避它们的方法。

4）进程虚拟地址空间的页7有3种状态：自由（free），预留（reserved）和提交（committed）。
* 都是以页为单位描述的。
* 自由表示此页尚未被分配，可以用来满足新的内存分配请求。
* 预留表示此段区域的代码以后使用，但是需要注意预留时并没有分配物理存储，只是增加了一个描述进程虚拟地址空间使用状态的数据结构（VAD，虚拟地址描述符（virtual address descriptor）），没有实际分配的物理存储，也就意味着无法直接访问，对预留页的访问会引起『内存访问违例』
* 提交表示希望得到真正的物理存储，必须对预留的内存进行提交，也就是说一个虚拟内存页的状态一定是从free->reserved->committed。提交这个操作是比较复杂的，需要好好的理解：
```
提交从调页文件中开辟空间，并修改VAD中的相应项。这个空间用作以后置换的备份空间（先给自己留后路，把置换空间准备好），并不分配真正的物理内存。

等到第一次访问这段提交内存中的某些数据时，系统发现没有真正的物理内存，抛出缺页错误，虚拟内存管理器处理此缺页错误，直到这时才会真正分配物理内存。

提交操作会从调页文件中开辟磁盘空间，所以比预留操作时间长。

从提交的一系列操作中可以看出Win32虚拟内存管理中的demand-paging的策略，即不到真正访问时，不会为某虚拟地址分配真正的物理内存，这种策略出于两个考虑：性能和空间效率。
具体说：
性能：将工作分段完成，提交操作先是在硬盘中分配了空间给调页文件，使其有了备份的能力。等到真正用到的时候，再进行内存的分配，这两个操作都是涉及到分配存储空间，相对比较耗时，所以分时段进行会提高性能。
空间效率：分成两部分说：
第一部分：某些程序对内存有很大的需求，但是也并非立即需要所有的这些内存，那么一次就从物理内存黄总开辟空间满足这些还只是『潜在』的需求，影响执行的性能和存储空间效率。
第二部分：如果每次都随虚分配内存来满足每次的请求，那么对一个会在不同时间点频繁请求内存的代码来说，因为在它请求内存的不同时间点的间隙极有可能会有其他代码请求内存。这样这段在不同时间点频繁请求内存的代码请求得到的内存因为虚拟地址不连续，无法很好地利用空间**locality特性**，对齐整体进行访问就会增加缺页错误的数量，从而降低程序的性能。
```
个人总结整理：提交这个操作采用了demand-paging这种lazy-allocate的机制（自己造的词），一个是延时操作，与COW（copy on write）有着异曲同工之妙，另一个与集中分配获得更好的locality。

线程栈就是使用了预留和提交两个机制，创建线程栈时，只是一个预留的虚拟地址区域，默认为1MB大小，随着虚拟内存管理器不断地动态的提交该虚拟地址区域的后续页以满足其需求，当提交最后一页时抛出一个栈溢出的异常，抛出栈异常的时候其实栈还有一页的空间可用，程序仍然可以正常运行。防止栈溢出崩溃需要处理栈溢出异常。
##### 访问虚拟内存时的处理流程：
5）使用一张流程图可以很清晰的描述这一过程。

#### Linux内存管理

