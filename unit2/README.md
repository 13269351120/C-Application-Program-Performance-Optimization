### 内联函数（编译期的优化）：
#### 预处理：将.h文件 递归展开 宏展开 
#### 编译：以编译单元进行编译，当进行编译的时候，编译器只能看到当前单元内的所有信息，内联是在这个时候进行的，内联函数的代码 需要在这个编译单元内找到。

#### 说说 为什么内联函数能优化:
* 普通的函数调用，经过了汇编语言的学习，在调用前，需要记录当前函数的基地址ebp,记录当前的eip，最后使得ebp和esp相等,正式开启新的栈空间，调用函数的所有变量就在当前的栈空间内完成，返回后，销毁该栈空间，而后还原 eip 和 ebp esp，回到原来的 栈空间，但内联函数不会有这样的开销。


* 更细节的：内联函数可以将信息更加完整的展现给编译器，这样编译器可以进行更好的优化，进一步提高效率。

* 更更细节的：内联后调用函数的代码都是相邻的，执行的代码都在同一个页面或者连续的页面中，提高了locality，减少了缺页的可能性。
#### 有利也有弊：
* 更更更细节的：内联函数如果很大，就会导致重复的代码很多，导致内存缺页，所以这个时候inline不一定管用，所以inline只是建议编译器可以内联。
也正因为内联函数会导致代码膨胀，所以递归函数拒绝内联，因为不知道具体的递归深度。

* 如果很多编译单元都用到了某个 内联函数，如果这个内联函数改动了，就会导致所有的用它的编译单元重新编译，这样会导致编译时间变长，所以，内联最好在开发的后期引入。如果是提供给别人使用的第三方库，一旦修改了内联函数的实现（没有修改接口），使用方就需要重新编译。


#### 一些杂散的点：
* 内联 与 宏定义： 内联是在编译期，宏定义在预处理期，宏定义只是简单的替换，而内联因为在编译期会进行类型的判断，宏定义一定会被展开，而内联不一定被展开。

* 编译器合成的默认构造函数拷贝构造函数，析构函数，赋值运算符一般都会内联。

* 虚函数不能内联的原因主要是它在运行时动态绑定，但是如果通过具体的对象调用而不是通过指针，那么从定义上看，虚函数此时和普通的函数没有区别，但这样虚函数的意义也就不大了。

